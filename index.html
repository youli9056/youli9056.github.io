
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>秦风汉雨</title>
	<meta name="author" content="You Li">

	
	<meta name="description" content="做了一段时间的Hadoop中的负载均衡问题，此文谨当做对那段时间的总结。 负载均衡 &ndash; 一个广泛而普遍存在的问题 负载均衡问题是一个广泛而普遍存在的问题。在所有的分布式系统中几乎都会提及到“长尾问题(Long Tail Problem)”，其实也就是大家常说的“短板理论”， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="秦风汉雨" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">秦风汉雨</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:youli9056.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		<a class="google" href="https://plus.google.com/102695714494549586316?rel=author" title="Google+">Google+</a>
		
		
		
		<a class="github" href="https://github.com/youli9056" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:youli9056.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/load-balancing-on-hadoop-mapreduce/">
		
			Hadoop MapReduce中的负载均衡问题 Load Balancing on Hadoop MapReduce</a>
	</h2>
	<div class="entry-content">
		<p>做了一段时间的Hadoop中的负载均衡问题，此文谨当做对那段时间的总结。</p>

<h2>负载均衡 &ndash; 一个广泛而普遍存在的问题</h2>

<p>负载均衡问题是一个广泛而普遍存在的问题。在所有的分布式系统中几乎都会提及到“长尾问题(Long Tail Problem)”，其实也就是大家常说的“短板理论”，系统的整体表现取决于表现最差的一部分。常见的分布式系统如分布式缓存，分布式存储，分布式计算，分布式数据库等等，都存在这个问题。分布式缓存中可能会遇到短时间内集中访问同一个缓存的情况；分布式存储可能单机磁盘使用过度；分布式计算可能会有单点的计算负担过重；分布式数据库可能会有单机访问量过大。如此总总，只要是分布的，想完全端平一碗水几乎是不大可能的。</p>

<p>在此，总结我对负载均衡的定义：在多点协作的系统中由于不合理的任务分配导致某个或者少量的某些节点处理负担过重，最终拖延整个系统对外的响应效率。</p>

<p>负载均衡的解决思路主要有：</p>

<pre><code>1. 被动解决，发现负载倾斜后，将负载迁移到空闲节点
2. 主动预防，防止倾斜的发生
    2.1 系统任务分配方式主动预防
        2.1.1 静态负载均衡
        2.1.2 动态负载均衡
    2.2 用户先验知识的介入
</code></pre>

<p>负载均衡问题的解决在大多数情况下是存在一个极限的，这取决于具体问题的可划分性。
分布式系统的负载均衡问题已经研究了多年了，有些问题早有了较成熟的解决方案，像分布式缓存系统中常见的一致性哈希算法等。在这里主要讨论的是分布式计算平台Hadoop里的负载均衡问题。</p>

<p>后文会对这几种方式一一讨论，下面先对本文的主要讨论对象Hadoop的背景做个简要介绍。</p>

<h2>Hadoop &ndash; 时代的宠儿</h2>

<p>Hadoop自推出以后在互联网快速发展的背景下得到了许多公司的认可，已然成为大数据的基础处理平台甚至是行业标准。Facebook，Amazon，Yahoo等等公司都在自己的系统中构建了基于Hadoop的处理平台。除了最基本的数据处理功能，在Hadoop之上现在已经发展出来一套生态系统，应用最广泛的莫过于Hive和HBase了。在Hadoop之上构建的系统都直接或间接地使用了了Hadoop的分布式存储模块HDFS和计算模块MapReduce。本文的问题关注计算模块MapReduce的均衡问题。</p>

<h3>HDFS</h3>

<p>HDFS借鉴的是Google的GFS系统，是一个基于Key/Value的分布式存储系统。HDFS是为了大文件、一次写多次读的应用场景而设计的。所有要存储在HDFS中的文件需要按块（默认64M）切分，每个数据块有在不同的机器上（默认是本机，本机架，不同机架）有多个备份（默认为3份）。系统通过对失败机器数据文件的再分配、复制来自动保证文件的数据安全。HDFS并不适合大量小文件或者对写要求高的场景。这样，我们可以有个概念，Hadoop中处理的数据会分块备份三分存在不同的机器上。</p>

<p>HDFS本身也存在负载均衡问题，这个负载的均衡主要只每台机器的磁盘使用率。假如有一台机器存储了大量的数据，而其他机器存储了很少，这就是一个倾斜的情形。HDFS的存储倾斜不仅仅只影响到磁盘使用情况，同时由于Hadoop的Map的执行依赖于输入数据在磁盘上的分布情况（Hadoop期望达到最好的数据本地化处理）它也影响到Map计算过程中的均衡。HDFS存储的不均很有可能导致Map计算的分布不均（注意是有可能，因为HDFS上的输入数据有多个备份，Map的输入只需要一份备份，因此不一定会导致Map计算不均）。</p>

<p>对于HDFS的倾斜问题，Hadoop本身提供了一套机制来限制不均衡的程度。Hadoop自带的工具<code>bin/start-balancer.sh</code>可以通过参数指定系统中均衡的标准如10%，这就保证了系统中磁盘的使用率的偏差在10%之内。如果超过了这个值，系统将自动执行数据块的重分布工作使之达到偏差限额。</p>

<h3>MapReduce</h3>

<p>MapReduce是Hadoop的数据处理模块，算是函数式编程的巅峰之作了吧。Hadoop对数据的处理都被抽象成Map和Reduce这两个函数的操作。</p>

<h4>Map</h4>

<p>通常地，Map函数的工作是从HDFS中读取上输入文件，读入的数据是一个个（MapInputKey/MapInputValue）对，根据作业需求处理后输出一个个（MapOutputKey/MapOutputValue)对，后台的输出线程会把输出的文件按照MapOutputKey把对应的MapOutputValue合并起来（MapOutputKey&ndash;>MapOutputValue0,MapOutputValue1,&hellip;)，同时还会将输出按照MapOutputKey排序（注意，每一个Map都会有同样的样的输出，不同的Map会有同样的Key值输出）。逻辑上，我们可以将不同Map输出的同一个Key的数据合起来看做一个小Partition（Finer Partition，FP）。</p>

<h4>Shuffle</h4>

<p>Shuffle被称为Hadoop的核心，但是对应一般用户并不会涉及到这部分的细节。系统提供一个Partition接口使得用户可以决定Map的输出Key该如何聚合（比如想把Key为奇数的FP放在一起，把偶数放在一起）。Shffle的主要工作是将各个Map的FP的各部分按照用户指定的方式将数据从Map的输出端拷贝到对应的Reduce执行端。</p>

<p>在大多数研究中Shuffle的倾斜问题都没有具体考虑，事实上Shuffle这个过程本身也是存在倾斜问题的。主要原因是各个机器上运行的reduce任务的处理数据量的不均。各个机器上运行的Reduce都要从Map端拷贝相应数据，如果这些要拷贝的数据在本地的话那么必然会拷贝得快些（虽然对于本地数据Hadoop的Shuffle还是使用的Http协议向本地Servlet请求下载）；另一方面，一台机器上有多个Reduce在同时下载数据，这台机器的网卡速度及磁盘读写能力都成为这台机器上的Shuffle过程的瓶颈因素。</p>

<p>然而Shuffle这部分倾斜被忽略并不是没有道理的。从企业生产的角度，我们并不关心单个机器的处理时间、通信量。事实上我们最关注的是，对于提交任务的用户而言有最快的响应速度；对整个系统集群而言网络通信量最小，单位时间内处理的任务最多。Shuffle的倾斜问题是中间的一个过渡状态，它是由Map数据的输出不均、任务分配不均导致的；同时它也有可能导致最终Reduce的任务处理时间差异。Shuffle过程中的倾斜并不一定导致最终的倾斜，相反在有些推测执行任务出现的时候，Shuffle的不均有可能还会提升最终性能表现。</p>

<p>总之，Shuffle的均衡既不是目标，也不是高性能的必要条件，因此对于这部分的研究意义不大。</p>

<h4>Reduce</h4>

<p>Reduce将Map输出的各个FP拷贝到本地(拷贝过程中还是保证键值对的有序性)，然后对于每个键值对序列(ReduceInputKey&ndash;> ReduceInputValue0，ReduceInputValue1&hellip;)做处理。对于MapReduce模型本身，如果要保证计算的正确性，我认为至少要保证的是：</p>

<blockquote><p>单独一个键的FP必须要保证完整的拷贝到同一台机器上。而不是看起来的，同一个Hash值对应到的Partition的多个键的FP数据要保证到同一台机器上。</p></blockquote>

<p>多数计算中即使多个键的FP被Shuffle到同一台机器上，处理时我们还是每次以一个键的FP作为独立的计算输入单元。因此，我们在写MapReduce程序时，应当需要注意的是：</p>

<blockquote><p>不应当将程序计算的正确性依赖于Partition函数的实现，而只应将Partition函数作为一个提升系统数据均衡性的用户接口。</p></blockquote>

<p>上面这一点也是我们下面提出的各种负载均衡算法的基本依据。如果用户程序不满足上的条件，那么对于这种应用只能做Reduce任务分配级别的均衡，再低层的均衡会影响程序的正确性。而这种问题，Hadoop本身的推测执行机制基本能够满足需求，因此下文不做讨论。也是均衡算法的能达到的上界(单个Key的FP是Reduce输入数据的最小不可分单元)。在此，下面都假设用户作业满足上面的条件。</p>

<h2>Hadoop倾斜发生的原因和位置</h2>

<p>负载均衡性本质上</p>

<p>关于分布式系统的负载均衡问题的研究已经有相当长时间了，现有解决方案</p>

<p>hadoop介绍</p>

<p>mapreduce简介</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-08T11:34:58+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/hadoop/'>hadoop</a>, <a class='category' href='/blog/categories/load-balance/'>load balance</a>, <a class='category' href='/blog/categories/mapreduce/'>mapreduce</a>


</div>
	
	<div class="comments"><a href="/blog/load-balancing-on-hadoop-mapreduce/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/java-jvm-memory-types/">
		
			Java(JVM)内存类型详解 Java(JVM) Memory Types</a>
	</h2>
	<div class="entry-content">
		

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-07T22:46:35+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/basics/'>basics</a>, <a class='category' href='/blog/categories/java/'>java</a>


</div>
	
	<div class="comments"><a href="/blog/java-jvm-memory-types/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/why-multiple-inheritance-is-not-supported-in-java/">
		
			Java为何不支持多继承 Why Multiple Inheritance Is Not Supported in Java</a>
	</h2>
	<div class="entry-content">
		<p>原文：<a href="http://javapapers.com/core-java/why-multiple-inheritance-is-not-supported-in-java/">http://javapapers.com/core-java/why-multiple-inheritance-is-not-supported-in-java/</a></p>

<p>James Gosling 在95年二月发表的名为“Java: an Overview”的白皮书中给出了为什么Java不支持多继承的思量。</p>

<blockquote><p>Java略去了好多C++中很少用到的，很难理解的，令人困惑的特性，根据我们的经验这些特性带来的麻烦比它们带来的好处更多。这些去掉的特征主要包括操作符重载(但是Java有方法重载)，<strong>多继承</strong>，广泛的自动强制类型转换。</p></blockquote>

<p>还有谁比James Gosling更有资格来对此作评论。这段话给了我们一个概要，并提起了不支持多继承的话题。</p>

<h2>Java不支持多继承</h2>

<hr />

<p>首先让我们来盖棺定论。Java到底支不支持多继承本身就是一个争议点。有人说Java支持多继承。<strong>不，Java中没有对多继承的支持</strong>。如果你不相信我的话，把上面Java之父的那段话再读一下。</p>

<p>用接口支持多继承的说法是我们这些开发人员自己编造出来的。接口比实体类提供了更高的灵活性，我们可以选择用单个类去实现多个接口。这样我们通过继承两个模板来构建一个类。</p>

<p>这样做是在尝试向多继承靠近。其实我们做的是实现多个接口，却没有继承任何东西。实现一个类的接口的工作是向其中添加属性和方法，而不能直接从父类中获取具体实现。简单地说，Java中没有堆多继承的支持。</p>


		
		<a href="/blog/why-multiple-inheritance-is-not-supported-in-java/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-06T21:43:11+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/basics/'>basics</a>, <a class='category' href='/blog/categories/java/'>java</a>


</div>
	
	<div class="comments"><a href="/blog/why-multiple-inheritance-is-not-supported-in-java/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/diference-between-interface-and-abstract-class/">
		
			接口和抽象类的区别 Diference Between Interface and Abstract Class</a>
	</h2>
	<div class="entry-content">
		<p>面试过程中经常会被问道Java中接口和抽象类有什么区别，总觉得自己总结不好，也不全面。正好这里<a href="http://javapapers.com/core-java/abstract-and-interface-core-java-2/difference-between-a-java-interface-and-a-java-abstract-class/">有篇文章</a>感觉写得很好。下面是内容。</p>

<ol>
<li><p>接口最主要的不同是，接口默认是抽象的，本身不能有任何实现。抽象类可以有为子类提供的默认实例方法。</p></li>
<li><p>接口中的变量默认是final的。抽象类可以包含非final的变量。</p></li>
<li><p>接口的成员默认是public的。抽象类可以有任意类型的成员，private，protected都可以。</p></li>
<li><p>实现接口需要用implements关键字。继承抽象类用extends关键字。</p></li>
<li><p>接口继承一个或者多个接口，但是不能继承或实现任意抽象抑或者实体类。抽象类可以继承另外一个Java类同时还可以实现多个Java接口。</p></li>
<li><p>一个Java类可以实现多个接口，但是只能继承一个抽象类。</p></li>
<li><p>接口是完全抽象的，不能够实例化。抽象类也是不能被实例化的，但是如果其中有main()方法时，还是可以调用。</p></li>
<li><p>和抽象类相比，接口定义的引用在具体执行时由于需要做额外的间接寻址工作因此会慢些。(执行时需要通过搜索具体类的实现方法)</p></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-06T18:03:19+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/basics/'>basics</a>, <a class='category' href='/blog/categories/java/'>java</a>


</div>
	
	<div class="comments"><a href="/blog/diference-between-interface-and-abstract-class/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/overloading-and-overriding/">
		
			深入理解重载和重写及与之相关的多态性 Overloading and Overriding</a>
	</h2>
	<div class="entry-content">
		<p>本文分割线之前非原创，翻译自<a href="http://javapapers.com/core-java/overloading-and-overriding/">Overloading and overriding</a>.</p>

<p>重载和重写除了在名称上有些相似之外，其实是完全不同的两个东西。</p>

<p>重载的目的是使得我们能够用用一个统一的接口名称来调用一系列方法。这些方法的目的也许是一样的，但是它们的实现方式会根据传入的参数不同而不同。</p>

<p>重写涉及到继承这个概念中的问题。子类继承了父类的方法，但是它可能需要有不同的操作行为，这时候就需要在子类中重写这个父类方法。</p>

<p>重载本身并不是多态，同时运行时绑定重载方法也不是多态的表现。它们以及一些其他的东西都是其面向对象多态性的使用（原文：All these and more are used to exercise the object oriented property polymorphism.总感觉翻译不要，故贴上来）。</p>

<h2>重载和重写的关键点</h2>

<ul>
<li>private： 一个私有的java方法是不能被重写的，因为它对子类压根就不可见</li>
<li>final：重载一个final的方法是可以的，但是不能重写它，因此父类如果将方法声明为final的就可保证所有子类的调用此方法时调用的都是父类的方法。</li>
<li>final：如果两个方法有同样的参数列表，而其中一个的参数被声明为final的这种情况下这两个方法完全一样，因此不可重载。编译都通不过，因为这两个方法被视为完全一样。</li>
<li>static：可以重载一个静态的Java方法但是不能重写静态的Java方法，因为静态方法在方法区中只有一个。</li>
<li>static：重载是关于对象(实例）和继承而言的。一个声明为静态的方法属于整个类(对于这个的所有对象都是一样的)。因此重写它没有任何意义。</li>
<li>static：对于重载，两个静态方法的重载没有什么特别的，只不过是修饰符多了个static修饰符。参数列表依然必须不同。</li>
</ul>



		
		<a href="/blog/overloading-and-overriding/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-05T16:03:56+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/basics/'>basics</a>, <a class='category' href='/blog/categories/java/'>java</a>


</div>
	
	<div class="comments"><a href="/blog/overloading-and-overriding/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/monitoring-and-analyzing-java-garbage-collection/">
		
			Java垃圾回收机制四 Monitoring and Analyzing Java Garbage Collection</a>
	</h2>
	<div class="entry-content">
		<p>在这篇Java垃圾回收系列文章中，让我们看下一些监控和分析垃圾回收的工具。然后用工具尝试监控和分析一个例子。初学者最好先看下<a href="/blog/categories/gc/">此系列</a>,从<a href="/blog/java-garbage-collection-introduction">Java 垃圾回收简介</a>开始吧。</p>

<h2>Java垃圾回收监控和分析工具</h2>

<p>下面是一些监控工具，它们有各自的优缺点。我们可以通过选择恰当的工具做一些有序的分析工作来提升应用性能。这篇文章将从Java VisualVM开始讲起。</p>

<ul>
<li>Java VisualVM</li>
<li>Naarad</li>
<li>GCViewer</li>
<li>IBM Pattern Modeling and Analysis Tool for Java Garbage Collector</li>
<li>HPjmeter</li>
<li>IBM Monitoring and Diagnostic Tools for Java &ndash; Garbage Collection and Memory</li>
<li>Visualizer</li>
<li>Verbose GC Analyzer</li>
</ul>


<h2>Java VisualVM</h2>

<p>Java VisualVM是在Java SE SDK安装时免费提供的。看下你的Java JDK安装目录下的<code>/bin</code>目录，<code>\Java\jdk1.8.0\bin</code>。此目录下有许多其他工具包括javac和java工具，jvisualvm就是其中一个。</p>


		
		<a href="/blog/monitoring-and-analyzing-java-garbage-collection/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-05T13:20:34+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/monitoring-and-analyzing-java-garbage-collection/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/types-of-java-garbage-collectors/">
		
			Java垃圾回收机制三 Types of Java Garbage Collectors</a>
	</h2>
	<div class="entry-content">
		<p>本文是Java垃圾回收系列的第三篇，非原创，翻译自<a href="http://javapapers.com/java/types-of-java-garbage-collectors/">Types of Java Garbage Collectors</a>。如果没有相应基础的话，阅读本文前建议先阅读前两篇<a href="/blog/java-garbage-collection-introduction/">Java Garbage Collection Introduction</a>(介绍了JVM的架构，堆内存模型和周边相关的Java术语)和<a href="/blog/java-gc-yuan-li/">How Java Garbage Collection Works?</a>(概况介绍了GC是如何工作的)</p>

<p>本文将会介绍各种不同类型的Java垃圾回收器。垃圾回收是Java用来将程序员从分配和释放内存的琐事中解放出来的自动过程。</p>

<p>Java有四种类型的垃圾回收器，</p>

<ol>
<li><a href="/blog/types-of-java-garbage-collectors/#serial-garbage-collector">Serial Garbage Collector</a></li>
<li><a href="/blog/types-of-java-garbage-collectors/#parallel-garbage-collector">Parallel Garbage Collector</a></li>
<li><a href="/blog/types-of-java-garbage-collectors/#cms-garbage-collector">CMS Garbage Collector</a></li>
<li><a href="/blog/types-of-java-garbage-collectors/#g1-garbage-collector">G1 Garbage Collector</a></li>
</ol>


<p><img src="/images/typesofjavagarbagecollectors/Types-of-Java-Garbage-Collectors3_th_thumb.jpg" alt="各种类型的Java垃圾回收器" /></p>


		
		<a href="/blog/types-of-java-garbage-collectors/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-05T11:07:33+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/types-of-java-garbage-collectors/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/java-garbage-collection-introduction/">
		
			Java垃圾回收机制一 简介&#8211;Java Garbage Collection Introduction</a>
	</h2>
	<div class="entry-content">
		<p>本文非原创，翻译自<a href="http://javapapers.com/java/java-garbage-collection-introduction/">Java Garbage Collection introduction</a>
在Java中为对象分配和释放内存空间都是由垃圾回收线程自动执行完成的。和C语言不一样的是Java程序员不需要手动写垃圾回收相关的代码。这是使得Java如此流行，同时也是Java能帮助程序员写出更好的Java应用的优点之一。</p>

<p>计划写一个介绍Java垃圾回收基础的系列文章，共分四部分：</p>

<ol>
<li><a href="/blog/java-garbage-collection-introduction/">Java垃圾回收简介</a></li>
<li><a href="/blog/java-gc-yuan-li/">Java垃圾回收器是如何工作的？</a></li>
<li><a href="/blog/types-of-java-garbage-collectors">各种类型的Java垃圾回收器</a></li>
<li><a href="/blog/monitoring-and-analyzing-java-garbage-collection">Java垃圾回收的监控和分析</a></li>
</ol>


<p>本文是这个系列的第一篇文章，这篇文章将会介绍一些基本术语，如：JDK，JVM，JRE，HotSpot VM，以及理解JVM的架构和Java堆内存结构。在开始学习Java垃圾回收机制之前确实有必要了解一下这些基本东西。</p>

<h2>关键的Java术语</h2>

<ul>
<li>Java API&ndash;一个帮助程序员创建Java应用的打包好的库集合</li>
<li>Java Development Kit(JDK)&ndash;一个使得程序员能够开发Java应用的工具集合</li>
<li>Java Virtual Machine(JVM)&ndash;JVM是一个抽象的计算机。Java程序是针对JVM规范写的。JVM是根据不同的操作系统平台实现的，它将Java指令翻译成对应平台上的指令，并执行。这样Java程序能够达到平台独立性。</li>
<li>Java Runtime Environment(JRE)&ndash;JRE由一个JVM的实现和Java API组成。</li>
</ul>


<h2>Java HotSpot虚拟机</h2>

<p>每个JVM的实现在对垃圾回收的原理的实现方式上会有一些不同。在收购SUN之前Oracle有JRockit JVM，收购SUN之后有了HotSpot虚拟机。目前Oracle同时维护了这两个虚拟机，并宣称将来会将两个虚拟机合并。</p>


		
		<a href="/blog/java-garbage-collection-introduction/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-04T15:49:16+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/java-garbage-collection-introduction/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/do-not-say-these-words-when-debuging/">
		
			Do Not Say These Words When Debuging</a>
	</h2>
	<div class="entry-content">
		<p>there is some interesting saying, when problems came out</p>

<blockquote><p>Bushit, that&rsquo;s impossible!</p>

<p>It&rsquo;s okay on my mechine!</p>

<p>It shouldn&rsquo;t&hellip;</p>

<p>It must be someone else&rsquo;s problem!</p>

<p>Why it&rsquo;s ok previously?</p></blockquote>

<p>HHHHHaaaa!</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-04T10:25:23+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/fun/'>fun</a>, <a class='category' href='/blog/categories/note/'>note</a>


</div>
	
	<div class="comments"><a href="/blog/do-not-say-these-words-when-debuging/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/java-gc-yuan-li/">
		
			Java垃圾回收机制二 工作原理&#8211;How Java Garbage Collection Works?</a>
	</h2>
	<div class="entry-content">
		<p>本文并非原创，翻译自文章<a href="http://javapapers.com/java/how-java-garbage-collection-works/">How Java Garbage Collection Works?</a>
这篇文章的主要目的是来理解Java垃圾回收机制的基本原理以及它是如何工作的。这是垃圾回收机制系列文章的第二篇。希望您已经读过了第一部分<a href="/blog/java-garbage-collection-introduction/">Java垃圾回收简介</a>.</p>

<p>Java垃圾回收是一个自动运行的管理程序运行时使用的内存的进程。通过GC的自动执行JVM将程序员从申请和释放内存的繁重操作中解放出来。</p>

<h2>Java垃圾回收GC初始化</h2>

<p>作为一个自动执行的进程，程序员不需要在代码中主动初始化GC。Java提供了<code>System.gc()</code>和<code>Runtime.gc()</code>这两个hook来请求JVM调用GC进程。</p>

<p>尽管要求系统机制给程序员提供调用GC的机会，但是实际上这是由JVM负责决定的。JVM可以选择拒绝启动GC的请求，因此并不保证这些请求会真的调用垃圾回收。这是JVM基于内存堆空间的Eden区的使用情况做出的决定。JVM规范将这个选择权利留给了各个JVM的具体实现，因此实际上JVM是如何选择的视不同JVM的实现而定(不过要记住的是，不能依赖于这两个方法的调用，它们是不被保证执行的)。</p>

<p>毫无疑问的是，我们知道垃圾回收进程是不能强制执行的。不过我刚发现一个调用<code>System.gc()</code>确实有意义的场景。看下这篇文章你就会了解<a href="http://javapapers.com/core-java/system-gc-invocation-a-suitable-scenario/">System.gc()调用是可用的</a>这个特殊的场景。</p>

<h2>Java 垃圾回收进程</h2>

<p>垃圾回收是一个回收不再使用的内存空间并将它变成能够为将来的实例使用的过程。<img src="/images/howjavaGCworks/Java-Garbage-Collection-Process3_thumb.jpg" alt="java gc collection process3" /></p>


		
		<a href="/blog/java-gc-yuan-li/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-10-22T19:34:46+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/java-gc-yuan-li/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    You Li

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'youli9056githubio';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-55942851-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



	<!--返回顶部开始-->
<div id="full" style="width:0px; height:0px; position:fixed; right:180px; bottom:150px; z-index:100; text-align:center; background-color:transparent; cursor:pointer;">
        <a href="#" onclick="goTop();return false;"><img src="/images/top.png" border=0 alt="返回顶部"></a>
</div>
<script src="/javascripts/top.js" type="text/javascript"></script>
<!--返回顶部结束-->

</body>
</html>
