
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>秦风汉雨</title>
	<meta name="author" content="You Li">

	
	<meta name="description" content="在这篇Java垃圾回收系列文章中，让我们看下一些监控和分析垃圾回收的工具。然后用工具尝试监控和分析一个例子。初学者最好先看下此系列,从Java 垃圾回收简介开始吧。 Java垃圾回收监控和分析工具 下面是一些监控工具，它们有各自的优缺点。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="秦风汉雨" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">秦风汉雨</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:youli9056.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		<a class="google" href="https://plus.google.com/102695714494549586316?rel=author" title="Google+">Google+</a>
		
		
		
		<a class="github" href="https://github.com/youli9056" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:youli9056.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/monitoring-and-analyzing-java-garbage-collection/">
		
			Monitoring and Analyzing Java Garbage Collection</a>
	</h2>
	<div class="entry-content">
		<p>在这篇Java垃圾回收系列文章中，让我们看下一些监控和分析垃圾回收的工具。然后用工具尝试监控和分析一个例子。初学者最好先看下<a href="/blog/categories/gc/">此系列</a>,从<a href="/blog/java-garbage-collection-introduction">Java 垃圾回收简介</a>开始吧。</p>

<h2>Java垃圾回收监控和分析工具</h2>

<p>下面是一些监控工具，它们有各自的优缺点。我们可以通过选择恰当的工具做一些有序的分析工作来提升应用性能。这篇文章将从Java VisualVM开始讲起。</p>

<ul>
<li>Java VisualVM</li>
<li>Naarad</li>
<li>GCViewer</li>
<li>IBM Pattern Modeling and Analysis Tool for Java Garbage Collector</li>
<li>HPjmeter</li>
<li>IBM Monitoring and Diagnostic Tools for Java &ndash; Garbage Collection and Memory</li>
<li>Visualizer</li>
<li>Verbose GC Analyzer</li>
</ul>


<h2>Java VisualVM</h2>

<p>Java VisualVM是在Java SE SDK安装时免费提供的。看下你的Java JDK安装目录下的<code>/bin</code>目录，<code>\Java\jdk1.8.0\bin</code>。此目录下有许多其他工具包括javac和java工具，jvisualvm就是其中一个。</p>

<p>Java VisualVM对运行中的Java应用提供了可视化的信息展示。它是很多工具的整合包，像工具JConsole,jstat,jinfo,jstack以及jmap现在都是Java VisualVM的一部分。</p>

<p>Java VisualVM可以用来
- 生成和分析堆内存的dump
- 观察和操作MBeans
- 监控垃圾回收
- 内存和CPU性能分析</p>

<h3>1. Launch VisualVM</h3>

<p><code>jvisualvm</code>已经包含在了JDK的bin目录下,如果以设置环境变量path，则可以直接在命令行中运行<code>jvisualvm</code>，将出现如下启动界面</p>

<p><img src="/images/monitoringandanalysisgc/Start-Java-VisualVM.png" alt="starting jvisualvm" /></p>

<p><img src="/images/monitoringandanalysisgc/Java-VisualVM.png" alt="jvisualvm view" /></p>

<h3>2.安装Visual GC插件</h3>

<p>我们需要安装visual GC 插件才能有个堆Java GC线程的漂亮和有价值的视觉感受。在上面的启动界面中点击工具->插件->可用插件->Visual GC</p>

<p><img src="/images/monitoringandanalysisgc/Visual-GC-Plugin.png" alt="visual gc" /></p>

<p>安装。</p>

<h3>3. 监控GC</h3>

<p>现在可以监控<a href="/blog/java-gc-yuan-li/">垃圾回收</a>过程了。开启你的Java应用程序，Java VisualVM会自动检测并将其显示到界面上。在左边“应用程序”面板的“本地”节点下面，所有本地运行的Java应用都会被列举出来。</p>

<p>Java VisualVM自己本身也是一个Java应用程序，因此它自身也被列了出来。作为本文的目的我们将监控VisualVM应用本身的GC过程。</p>

<p>双击“本地”节点下的VisualVM图标。</p>

<p><img src="/images/monitoringandanalysisgc/GC-Analysis.jpg" alt="visualvm gc" /></p>

<p>这样应用程序的监控面板会在右边打开。面板上有多个标签，每个里面展示了与应用程序性能相关的方面。由于我们现在主要关注“Visual GC”，so，点之。</p>

<p><img src="/images/monitoringandanalysisgc/Heap-Memory-Space-Allocation.png" alt="Heap Memory Space Allocation" /></p>

<p>上面的图片显示了Old，Eden，S0，S1使用的内存空间。下面的图表显示了各个部分申请和释放内存的详细信息。它以设定的刷新频率不停地跟新。</p>

<p><img src="/images/monitoringandanalysisgc/GC-Graphs.png" alt="gc graph" /></p>

<p>上图显示的是一个正常运行的程序。当发生内存泄露或者不正常的操作时，可以从图形本身明显地看出来。至少我们可以知道程序中存在和对象内存分配和垃圾回收相关的问题。然后利用其他标签如“Threads”中提供的信息和Thread Dump我们可以缩小发生问题的范围。</p>

<p>在“监视”标签中，我们可以看到以时间线发展的内存使用概况图。这里有个“执行垃圾回收”按钮可以调用垃圾回收过程。
<img src="/images/monitoringandanalysisgc/Perform-GC.png" alt="perform gc" /></p>

<p>在“抽样器”标签中我们可以开始内存和CPU分析工作。抽样器会实时显示各个实例的使用情况。它可以帮助确定性能问题到底发生在哪里。</p>

<p><img src="/images/monitoringandanalysisgc/Instances-Memory-Allocation.png" alt="instance memory allocation" /></p>

<p>到此为止，关于<a href="/blog/categories/gc/">Java 垃圾回收的系列文章</a>已经完结了。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-05T13:20:34+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/monitoring-and-analyzing-java-garbage-collection/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/types-of-java-garbage-collectors/">
		
			Types of Java Garbage Collectors</a>
	</h2>
	<div class="entry-content">
		<p>本文是Java垃圾回收系列的第三篇，非原创，翻译自<a href="http://javapapers.com/java/types-of-java-garbage-collectors/">Types of Java Garbage Collectors</a>。如果没有相应基础的话，阅读本文前建议先阅读前两篇<a href="/blog/java-garbage-collection-introduction/">Java Garbage Collection Introduction</a>(介绍了JVM的架构，堆内存模型和周边相关的Java术语)和<a href="/blog/java-gc-yuan-li/">How Java Garbage Collection Works?</a>(概况介绍了GC是如何工作的)</p>

<p>本文将会介绍各种不同类型的Java垃圾回收器。垃圾回收是Java用来将程序员从分配和释放内存的琐事中解放出来的自动过程。</p>

<p>Java有四种类型的垃圾回收器，</p>

<ol>
<li><a href="/blog/types-of-java-garbage-collectors/#serial-garbage-collector">Serial Garbage Collector</a>

<ol>
<li><a href="#parallel-garbage-collector">Parallel Garbage Collector</a></li>
<li><a href="#cms-garbage-collector">CMS Garbage Collector</a></li>
<li><a href="#g1-garbage-collector">G1 Garbage Collector</a></li>
</ol>
</li>
</ol>


<p><img src="/images/typesofjavagarbagecollectors/Types-of-Java-Garbage-Collectors3_th_thumb.jpg" alt="各种类型的Java垃圾回收器" /></p>

<p>这四种类型的垃圾回收器都有各自的优点和缺点。最重要的是程序员可以选择JVM使用哪种类型的垃圾回收器。我们可以通过传递不同的JVM参数来设置使用哪一个。各个垃圾回收器在不同应用场景下的效率会有很大的差异。因此了解各种不同类型的垃圾回收器以及它们的应用场景是非常重要的。</p>

<h2>1. Serial Garbage Collector</h2>

<p>串行垃圾回收器控制所有的应用线程。它是为单线程场景设计的，只使用一个线程来执行垃圾回收工作。它暂停所有应用线程来执行垃圾回收工作的方式不适用于服务器的应用环境。它最适用的是简单的命令行程序。</p>

<p>使用<code>-XX:+UseSerialGC</code>JVM参数来开启使用串行垃圾回收器。</p>

<h2>2. Parallel Garbage Collector</h2>

<p>并行垃圾回收器也称作基于吞吐量的回收器。它是JVM的默认垃圾回收器。与Serial不同的是，它使用多个线程来执行垃圾回收工作。和Serial回收器一样，它在执行垃圾回收工作是也需要暂停所有应用线程。</p>

<h2>3. CMS Garbage Collector</h2>

<p>并发标记清除(Concurrent Mark Sweep,CMS)垃圾回收器，使用多个线程来扫描堆内存并标记可被清除的对象，然后清除标记的对象。CMS垃圾回收器只在下面这两种情形下暂停工作线程，</p>

<ol>
<li>在老年代中标记引用对象的时候</li>
<li>在做垃圾回收的过程中堆内存中有变化发生</li>
</ol>


<p>对比与并行垃圾回收器，CMS回收器使用更多的CPU来保证更高的吞吐量。如果我们可以有更多的CPU用来提升性能，那么CMS垃圾回收器是比并行回收器更好的选择。</p>

<p>使用<code>-XX:+UseParNewGC</code>JVM参数来开启使用CMS垃圾回收器。</p>

<h2>4. G1 Garbage Collector</h2>

<p>G1垃圾回收器应用于大的堆内存空间。它将堆内存空间划分为不同的区域，对各个区域并行地做回收工作。G1在回收内存空间后还立即堆空闲空间做整合工作以减少碎片。CMS却是在全部停止(stop the world,STW)时执行内存整合工作。对于不同的区域G1根据垃圾的数量决定优先级。</p>

<p>使用<code>-XX:UseG1GC</code>JVM参数来开启使用G1垃圾回收器。</p>

<p><strong>Java 8 的优化</strong></p>

<p>在使用G1垃圾回收器是，开启使用<code>-XX:+UseStringDeduplacaton</code>JVM参数。它会通过把重复的String值移动到同一个char[]数组来优化堆内存占用。这是<em>Java 8 u 20</em>引入的选项。</p>

<p>以上给出的四个Java垃圾回收器，在什么时候使用哪一个去决于应用场景，硬件配置和吞吐量要求。</p>

<h2>Garbage Collection JVM Options</h2>

<p>下面是些主要的与Java垃圾回收相关的JVM选项。</p>

<h3>Type of Garbage Collector to run</h3>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>串行垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>并行垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>CMS垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallesCMSThread=</td>
<td>CMS垃圾回收器&ndash;使用的线程数量</td>
</tr>
<tr>
<td>-XX:UseG1GC</td>
<td>G1垃圾回收器</td>
</tr>
</tbody>
</table>


<h3>GC 优化选项</h3>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>初始堆内存大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆内存大小</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代的大小</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>初始永久代的大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>最大的永久代的大小</td>
</tr>
</tbody>
</table>


<h3>Example Usage of JVM GC Options</h3>

<pre><code>java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar
</code></pre>

<p>在垃圾回收系列的<a href="/blog/monitoring-and-analyzing-java-garbage-collection/">下一篇</a>中，将通过一个例子介绍如何区监控和分析垃圾回收。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-05T11:07:33+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/types-of-java-garbage-collectors/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/java-garbage-collection-introduction/">
		
			Java Garbage Collection Introduction</a>
	</h2>
	<div class="entry-content">
		<p>本文非原创，翻译自<a href="http://javapapers.com/java/java-garbage-collection-introduction/">Java Garbage Collection introduction</a>
在Java中为对象分配和释放内存空间都是由垃圾回收线程自动执行完成的。和C语言不一样的是Java程序员不需要手动写垃圾回收相关的代码。这是使得Java如此流行，同时也是Java能帮助程序员写出更好的Java应用的优点之一。</p>

<p>计划写一个介绍Java垃圾回收基础的系列文章，共分四部分：</p>

<ol>
<li><a href="/blog/java-garbage-collection-introduction/">Java垃圾回收简介</a></li>
<li><a href="/blog/java-gc-yuan-li/">Java垃圾回收器是如何工作的？</a></li>
<li><a href="/blog/types-of-java-garbage-collectors">各种类型的Java垃圾回收器</a></li>
<li><a href="/blog/monitoring-and-analyzing-java-garbage-collection">Java垃圾回收的监控和分析</a></li>
</ol>


<p>本文是这个系列的第一篇文章，这篇文章将会介绍一些基本术语，如：JDK，JVM，JRE，HotSpot VM，以及理解JVM的架构和Java堆内存结构。在开始学习Java垃圾回收机制之前确实有必要了解一下这些基本东西。</p>

<h2>关键的Java术语</h2>

<ul>
<li>Java API&ndash;一个帮助程序员创建Java应用的打包好的库集合</li>
<li>Java Development Kit(JDK)&ndash;一个使得程序员能够开发Java应用的工具集合</li>
<li>Java Virtual Machine(JVM)&ndash;JVM是一个抽象的计算机。Java程序是针对JVM规范写的。JVM是根据不同的操作系统平台实现的，它将Java指令翻译成对应平台上的指令，并执行。这样Java程序能够达到平台独立性。</li>
<li>Java Runtime Environment(JRE)&ndash;JRE由一个JVM的实现和Java API组成。</li>
</ul>


<h2>Java HotSpot虚拟机</h2>

<p>每个JVM的实现在对垃圾回收的原理的实现方式上会有一些不同。在收购SUN之前Oracle有JRockit JVM，收购SUN之后有了HotSpot虚拟机。目前Oracle同时维护了这两个虚拟机，并宣称将来会将两个虚拟机合并。</p>


		
		<a href="/blog/java-garbage-collection-introduction/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-04T15:49:16+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/java-garbage-collection-introduction/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/do-not-say-these-words-when-debuging/">
		
			Do Not Say These Words When Debuging</a>
	</h2>
	<div class="entry-content">
		<p>there is some interesting saying, when problems came out</p>

<blockquote><p>Bushit, that&rsquo;s impossible!</p>

<p>It&rsquo;s okay on my mechine!</p>

<p>It shouldn&rsquo;t&hellip;</p>

<p>It must be someone else&rsquo;s problem!</p>

<p>Why it&rsquo;s ok previously?</p></blockquote>

<p>HHHHHaaaa!</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-04T10:25:23+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/fun/'>fun</a>, <a class='category' href='/blog/categories/note/'>note</a>


</div>
	
	<div class="comments"><a href="/blog/do-not-say-these-words-when-debuging/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/java-gc-yuan-li/">
		
			Java 垃圾回收机制工作原理&#8211;How Java Garbage Collection Works?</a>
	</h2>
	<div class="entry-content">
		<p>本文并非原创，翻译自文章<a href="http://javapapers.com/java/how-java-garbage-collection-works/">How Java Garbage Collection Works?</a>
这篇文章的主要目的是来理解Java垃圾回收机制的基本原理以及它是如何工作的。这是垃圾回收机制系列文章的第二篇。希望您已经读过了第一部分<a href="/blog/java-garbage-collection-introduction/">Java垃圾回收简介</a>.</p>

<p>Java垃圾回收是一个自动运行的管理程序运行时使用的内存的进程。通过GC的自动执行JVM将程序员从申请和释放内存的繁重操作中解放出来。</p>

<h2>Java垃圾回收GC初始化</h2>

<p>作为一个自动执行的进程，程序员不需要在代码中主动初始化GC。Java提供了<code>System.gc()</code>和<code>Runtime.gc()</code>这两个hook来请求JVM调用GC进程。</p>

<p>尽管要求系统机制给程序员提供调用GC的机会，但是实际上这是由JVM负责决定的。JVM可以选择拒绝启动GC的请求，因此并不保证这些请求会真的调用垃圾回收。这是JVM基于内存堆空间的Eden区的使用情况做出的决定。JVM规范将这个选择权利留给了各个JVM的具体实现，因此实际上JVM是如何选择的视不同JVM的实现而定(不过要记住的是，不能依赖于这两个方法的调用，它们是不被保证执行的)。</p>

<p>毫无疑问的是，我们知道垃圾回收进程是不能强制执行的。不过我刚发现一个调用<code>System.gc()</code>确实有意义的场景。看下这篇文章你就会了解<a href="http://javapapers.com/core-java/system-gc-invocation-a-suitable-scenario/">System.gc()调用是可用的</a>这个特殊的场景。</p>

<h2>Java 垃圾回收进程</h2>

<p>垃圾回收是一个回收不再使用的内存空间并将它变成能够为将来的实例使用的过程。<img src="/images/howjavaGCworks/Java-Garbage-Collection-Process3_thumb.jpg" alt="java gc collection process3" /></p>


		
		<a href="/blog/java-gc-yuan-li/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-10-22T19:34:46+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/gc/'>gc</a>, <a class='category' href='/blog/categories/java/'>java</a>, <a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/java-gc-yuan-li/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/markdownlearn/">
		
			Markdown Learn</a>
	</h2>
	<div class="entry-content">
		<h1>A First Level Header</h1>

<p>Some of these words <em>are emphasized</em>.
Some of these words <em>are emphasized also</em>.
Use two asterisks for <strong>strong emphasis</strong>.
Or, if you prefer, <strong>use two underscores instead</strong>.</p>

<h2>A Second Level Header</h2>

<p>Now is the time for all good men to come to the aid of their country,
This is just a regular paragraph.</p>

<p>The quick brown fox jumped over the lazy dog&rsquo;s back.</p>

<h3>Header 3</h3>

<blockquote><p>This is a blockquote.</p>

<p>This is the second paragraph in the blockquote.</p>

<p>This is an H2 in a blockquote</p></blockquote>

<p>Some of these words <em>are emphasized</em>.
Some of these words <em>are emphasized also</em>.
Use two asterisks for <strong>strong emphasis</strong>.
Or, if you prefer, <strong>use two underscores instead</strong>.</p>

<h3>Lists</h3>

<h4>无序列表</h4>

<p>无序列表使用星号，加号和减号作为列表项目的标记</p>

<h5>星号</h5>

<ul>
<li>Candy.</li>
<li>Gum.</li>
<li>Booze.

<h5>加号</h5></li>
<li>Candy.</li>
<li>Gum.</li>
<li>Booze.

<h5>减号</h5></li>
<li>Candy.</li>
<li>Gum.</li>
<li>Booze.

<h5>混合使用</h5></li>
<li>Candy.</li>
<li>Gum.</li>
<li>Booze.
由上面的测试可以显示，三者之间是完全等价的（<strong>符号和内容之间要有一个空格</strong>）

<h4>有序列表</h4>

<p>有序列表使用数字接着一个英文句点作为项目标记：</p></li>
<li>Red</li>
<li>Green</li>
<li>Bule
<strong>句点和内容之间要有一个空格</strong>

<h4>项目之间的空行问题</h4></li>
<li><p>A list item.</p>

<p>  With multiple paragraphs.</p></li>
<li><p>Another item in the list.</p></li>
</ul>



		
		<a href="/blog/markdownlearn/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-08-18T01:07:36+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/blog/'>blog</a>, <a class='category' href='/blog/categories/markdown/'>markdown</a>, <a class='category' href='/blog/categories/octopress/'>octopress</a>


</div>
	
	<div class="comments"><a href="/blog/markdownlearn/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    You Li

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'youli9056githubio';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-55942851-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



	<!--返回顶部开始-->
<div id="full" style="width:0px; height:0px; position:fixed; right:180px; bottom:150px; z-index:100; text-align:center; background-color:transparent; cursor:pointer;">
        <a href="#" onclick="goTop();return false;"><img src="/images/top.png" border=0 alt="返回顶部"></a>
</div>
<script src="/javascripts/top.js" type="text/javascript"></script>
<!--返回顶部结束-->

</body>
</html>
