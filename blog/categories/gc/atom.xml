<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gc | 秦风汉雨]]></title>
  <link href="http://youli9056.github.io/blog/categories/gc/atom.xml" rel="self"/>
  <link href="http://youli9056.github.io/"/>
  <updated>2014-10-23T22:53:16+08:00</updated>
  <id>http://youli9056.github.io/</id>
  <author>
    <name><![CDATA[You Li]]></name>
    <email><![CDATA[youli9056@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java 垃圾回收机制工作原理--How Java Garbage Collection Works?]]></title>
    <link href="http://youli9056.github.io/blog/java-gc-yuan-li/"/>
    <updated>2014-10-22T19:34:46+08:00</updated>
    <id>http://youli9056.github.io/blog/java-gc-yuan-li</id>
    <content type="html"><![CDATA[<p>本文并非原创，翻译自文章<a href="http://javapapers.com/java/how-java-garbage-collection-works/">How Java Garbage Collection Works?</a>
这篇文章的主要目的是来理解Java垃圾回收机制的基本原理以及它是如何工作的。这是垃圾回收机制系列文章的第二篇。希望您已经读过了第一部分<a href="http://javapapers.com/java/java-garbage-collection-introduction/">Java垃圾回收导论</a>.</p>

<p>Java垃圾回收是一个自动运行的管理程序运行时使用的内存的进程。通过GC的自动执行JVM将程序员从申请和释放内存的繁重操作中解放出来。</p>

<h2>Java垃圾回收GC初始化</h2>

<p>作为一个自动执行的进程，程序员不需要在代码中主动初始化GC。Java提供了<code>System.gc()</code>和<code>Runtime.gc()</code>这两个hook来请求JVM调用GC进程。</p>

<p>尽管要求系统机制给程序员提供调用GC的机会，但是实际上这是由JVM负责决定的。JVM可以选择拒绝启动GC的请求，因此并不保证这些请求会真的调用垃圾回收。这是JVM基于内存堆空间的Eden区的使用情况做出的决定。JVM规范将这个选择权利留给了各个JVM的具体实现，因此实际上JVM是如何选择的视不同JVM的实现而定(不过要记住的是，不能依赖于这两个方法的调用，它们是不被保证执行的)。</p>

<p>毫无疑问的是，我们知道垃圾回收进程是不能强制执行的。不过我刚发现一个调用<code>System.gc()</code>确实有意义的场景。看下这篇文章你就会了解<a href="http://javapapers.com/core-java/system-gc-invocation-a-suitable-scenario/">System.gc()调用是可用的</a>这个特殊的场景。</p>

<h2>Java 垃圾回收进程</h2>

<p>垃圾回收是一个回收不再使用的内存空间并将它变成能够为将来的实例使用的过程。<img src="/images/howjavaGCworks/Java-Garbage-Collection-Process3_thumb.jpg" alt="java gc collection process3" /></p>

<p><strong>Eden Space:</strong>当一个实例被创建的时候，它最初被存放在堆内存空间的年轻代的Eden区中。</p>

<p><em>注意：如果您不太理解这些术语，建议您先看下介绍内存模型、JVM架构及这些术语的详细解释的文章：<a href="http://javapapers.com/java/java-garbage-collection-introduction/">garbage-collection-introduction-tutorial</a></em></p>

<p><strong>Survivor Space(S0 和S1):</strong>作为minor回收周期的一部分，还活着的对象（还有引用指向它）被从eden区中移动到survivor空间S0。同样的，垃圾回收器扫描S0并将活着的实例移动到S1。</p>

<p>无用的对象（没有引用指向）被标记并回收。垃圾回收器（有四种可用的垃圾回收器，将在下一篇文章中介绍）决定这些被标记的实例是在扫描的过程中移出内存还是在另外独立的迁移进程中执行。</p>

<p><strong>Old Generation:</strong>老年代或者永久代是堆内存的第二个逻辑部分。当垃圾回收器在做minor GC周期中，S1 survivor区中还活着的实例会被提升到老年代中。S1区中不再被引用的对象被标记并清除。</p>

<p><strong>Major GC:</strong>在Java垃圾回收过程中实例生命周期的最后一个阶段。Major GC在垃圾回收过程中扫描属于Old Generation部分的堆内存。如果实例没有被任何引用关联，它们将被标记、清除；如果它们还被引用关联着，则将继续存留在old generation。</p>

<blockquote><p><strong>Memory Fragmentation:</strong>一旦实例从堆内存中删除了，它们原来的位置将空出来给以后分配实例使用。显然这些空闲空间很容易在内存空间中产生碎片。为了能够更快地分配实例地址，需要对内存做去碎片化操作。根据不同垃圾回收器的策略，被回收的内存将在回收的过程同时或者在GC另外独立的过程中压缩整合。</p></blockquote>

<h2>垃圾回收过程中的对象销毁&ndash;Finalization</h2>

<p>就在移除一个对象并回收它的内存空间之前，Java垃圾回收器将会调用各个实例的<code>finalize()</code>方法，这样实例对象就有机会可以释放掉它占用的资源。尽管<code>finalize()</code>方法是保证在回收内存空间之前执行的，但是对具体的执行时间和执行顺序是没有任何保证的。多个实例之间的<code>finalize()</code>执行顺序是不能提前预知的，甚至有可能它们是并行执行的。程序不应该预先假设实例执行<code>finalize()</code>的方法，也不应该使用<code>finalize()</code>方法来回收资源。</p>

<ul>
<li>在finalize过程中抛出的任何异常都默认被忽略掉了，同时对象的销毁过程被取消</li>
<li>JVM规范并没有讨论关于弱引用的垃圾回收，这是明确声明的。具体的细节留给实现者决定。</li>
<li>垃圾回收是由守护进程执行的</li>
</ul>


<h2>对象何时变成可被垃圾回收的？</h2>

<ul>
<li>所有不能被活着的线程到达实例</li>
<li>不能被其他对象到达的循环引用对象
Java中有<a href="http://javapapers.com/core-java/java-weak-reference/">多种不同的引用类型</a>。实例的可回收性取决于它的引用类型。
|| <em>Year</em> || <em>Temperature (low)</em> || <em>Temperature (high)</em> ||
|| 1900 || -10 || 25 ||
|| 1910 || -15 || 30 ||
|| 1920 || -10 || 32 ||</li>
</ul>

]]></content>
  </entry>
  
</feed>
